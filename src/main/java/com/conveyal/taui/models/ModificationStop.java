package com.conveyal.taui.models;

import com.conveyal.r5.analyst.scenario.StopSpec;
import com.conveyal.r5.util.ExceptionUtils;
import com.conveyal.taui.AnalysisServerException;
import com.vividsolutions.jts.geom.Coordinate;
import org.geotools.geometry.jts.JTS;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.TransformException;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.stream.Collectors;

/**
 * An intermediate step between the front-end representation of new or extended trips and the form that R5 expects.
 * Ideally we'd just convert directly to those R5 StopSpecs, but we need to use this intermediate type to track
 * distanceFromStart for generating hop times from speeds.
 * See conveyal/analysis-backend#175 for a potential cleaner solution.
 */
class ModificationStop {

    // General Constants
    private static double MIN_SPACING_PERCENTAGE = 0.25;
    private static int DEFAULT_SEGMENT_SPEED_KPH = 15;

    // Conversion Factors
    public static int SECONDS_PER_HOUR = 60 * 60;
    public static int METERS_PER_KM = 1000;

    /** The WGS84 latitude and longitude of the stop. */
    private final Coordinate coordinate;

    /** The GTFS stop_id of a stop if it's being reused, or null if it was newly created in the editor. */
    private final String id;

    /**
     * The distance of a stop from the beginning of the trip in meters, used for generating travel times from speeds.
     * See conveyal/analysis-backend#175 for a way to elimiate this (persist the times instead of the speeds.)
     */
    private final double distanceFromStart;

    /** True if the stop was one of the ones generated automatically at regular intervals along the new route. */
    private final boolean autoGenerated;

    /**
     * Constructor for ModificationStops. It creates an immutable object with all fields final.
     */
    private ModificationStop (Coordinate c, String id, double distanceFromStart, boolean autoGenerated) {
        this.coordinate = c;
        this.id = id;
        this.distanceFromStart = distanceFromStart;
        this.autoGenerated = autoGenerated;
    }

    /**
     * Convert a list of ModificationStops (which are internal to the backend conversion process) to a list of the
     * StopSpec type required by r5.
     */
    static List<StopSpec> toStopSpecs (List<ModificationStop> stops) {
        return stops.stream()
                .map(s -> {
                    if (s.id == null || s.autoGenerated){
                        return new StopSpec(s.coordinate.x, s.coordinate.y);
                    } else {
                        // Stop references an existing GTFS stop ID, send that instead of its coordinates.
                        return new StopSpec(s.id);
                    }
                })
                .collect(Collectors.toList());
    }

    /**
     * Convert a list of Segments from a modification (the front-end representation) to this internal
     * backend representation.
     */
    static List<ModificationStop> getStopsFromSegments (List<Segment> segments) {

        // Keep a stack of Stops because as part of auto-generating stops we sometimes need to back one out.
        Stack<ModificationStop> stops = new Stack<>();
        CoordinateReferenceSystem crs = DefaultGeographicCRS.WGS84;

        if (segments == null || segments.size() == 0) {
            return new ArrayList<>();
        }

        Segment firstSegment = segments.get(0);

        if (firstSegment.stopAtStart) {
            stops.add(new ModificationStop(firstSegment.geometry.getCoordinates()[0],
                    firstSegment.fromStopId, 0, false));
        }

        double distanceToLastStop = 0; // distance to previously created stop, from start of pattern
        double distanceToLineSegmentStart = 0; // from start of pattern
        for (Segment segment : segments) {
            // TODO sanity check that each segment's final point matches the first point of the next segment
            Coordinate[] coords = segment.geometry.getCoordinates();
            int spacing = segment.spacing;
            boolean autoCreateStops = spacing > 0;
            for (int i = 1; i < coords.length; i++) {
                Coordinate c0 = coords[i - 1];
                Coordinate c1 = coords[i];
                double distanceThisLineSegmentMeters;
                try {
                    // JTS orthodromic distance returns meters, considering the input coordinate system.
                    distanceThisLineSegmentMeters = JTS.orthodromicDistance(c0, c1, crs);
                } catch (TransformException e) {
                    throw AnalysisServerException.unknown(ExceptionUtils.asString(e));
                }
                if (autoCreateStops) {
                    // Auto-create stops while this segment includes at least one point that is more than 'spacing'
                    // meters farther along the pattern than the previously created stop
                    while (distanceToLastStop + spacing < distanceToLineSegmentStart + distanceThisLineSegmentMeters) {
                        double frac = (distanceToLastStop + spacing - distanceToLineSegmentStart) / distanceThisLineSegmentMeters;
                        if (frac < 0) frac = 0;
                        Coordinate c = new Coordinate(c0.x + (c1.x - c0.x) * frac, c0.y + (c1.y - c0.y) * frac);

                        // We can't just add segment.spacing because of converting negative fractions to zero above.
                        // This can happen when the last segment did not have automatic stop creation, or had a larger
                        // spacing. TODO in the latter case, we probably want to continue to apply the spacing from the
                        // last line segment until we create a new stop?
                        distanceToLastStop = distanceToLineSegmentStart + frac * distanceThisLineSegmentMeters;

                        // Add the auto-created stop to the stack, flagging it as an auto-created one.
                        stops.add(new ModificationStop(c, null, distanceToLastStop, true));
                    }
                }
                distanceToLineSegmentStart += distanceThisLineSegmentMeters;
            }

            if (segment.stopAtEnd) {
                // If the last auto-generated stop was too close to a manually created stop (other than the first stop),
                // remove it.
                if (autoCreateStops && stops.size() > 1) {
                    ModificationStop lastStop = stops.peek();
                    if (lastStop.autoGenerated
                            && (distanceToLineSegmentStart - distanceToLastStop) / spacing < MIN_SPACING_PERCENTAGE) {
                        stops.pop();
                    }
                }

                Coordinate endCoord = coords[coords.length - 1];
                stops.add(new ModificationStop(endCoord, segment.toStopId, distanceToLineSegmentStart, false));
                // restart the auto-generated stop spacing
                // distanceToLineSegmentStart was already set to the next line segment
                distanceToLastStop = distanceToLineSegmentStart;
            }
        }

        return new ArrayList<>(stops);
    }

    static int[] getDwellTimes (List<ModificationStop> stops, Integer[] dwellTimes, int defaultDwellTime) {
        if (stops == null || stops.size() == 0) {
            return new int[0];
        }

        int[] stopDwellTimes = new int[stops.size()];

        // This "real" stop index is the index into the originally supplied stops, ignoring the auto-generated ones.
        int realStopIndex = 0;
        for (int i = 0; i < stops.size(); i++) {
            if (stops.get(i).autoGenerated || dwellTimes == null || dwellTimes.length <= realStopIndex) {
                stopDwellTimes[i] = defaultDwellTime;
            } else {
                Integer specificDwellTime = dwellTimes[realStopIndex];
                stopDwellTimes[i] = specificDwellTime != null ? specificDwellTime : defaultDwellTime;
                realStopIndex++;
            }
        }

        return stopDwellTimes;
    }

    static int[] getHopTimes (List<ModificationStop> stops, int[] segmentSpeedsKph) {
        if (stops == null || stops.size() < 2) {
            return new int[0];
        }

        int[] hopTimesSeconds = new int[stops.size() - 1];
        ModificationStop lastStop = stops.get(0);

        // This "real" stop index is the index into the originally supplied stops, ignoring the auto-generated ones.
        int realStopIndex = 0;
        for (int i = 0; i < hopTimesSeconds.length; i++) {
            ModificationStop stop = stops.get(i + 1);
            double hopDistance = stop.distanceFromStart - lastStop.distanceFromStart;

            int segmentSpeedKph = segmentSpeedsKph.length > realStopIndex ? segmentSpeedsKph[realStopIndex] :
                    DEFAULT_SEGMENT_SPEED_KPH;
            hopTimesSeconds[i] = (int) (hopDistance / (segmentSpeedKph * METERS_PER_KM) * SECONDS_PER_HOUR);

            if (stop.autoGenerated) {
                realStopIndex++;
            }

            lastStop = stop;
        }

        return hopTimesSeconds;
    }

}
